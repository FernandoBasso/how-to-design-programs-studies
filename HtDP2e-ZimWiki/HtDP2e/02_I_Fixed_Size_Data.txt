Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.6
Creation-Date: 2020-09-26T10:43:22-03:00

====== 02 I Fixed Size Data ======
Created Saturday 26 September 2020

===== 1 Arithmetic =====
In the book: [[https://htdp.org/2020-8-1/Book/part_one.html#%28part._ch~3abasic-arithmetic%29|I Fixed Size Data]]

==== 1.1 The Arithmetic of Numbers ====
In the book: [[https://htdp.org/2020-8-1/Book/part_one.html#%28part._sec~3aarith-num%29|The Arithmetic of Numbers]]

Expressions like these:

'''
(+ 1 (+ 1 (+ 1 1) 2) 3 (+ 2 2) 5)
(+ 1 (+ 1 2 2) 3 4 5)
(+ 1 5 3 4 5)
18
'''

Atomic data is data that cannot be further inspected.

BSL uses //prefix notation//, that is ''(+ 1 2)'' rather than something like ''1 + 2''.

''+'', ''-'', ''*'', ''/'', ''abs'', ''add1'', ''ceiling'', ''denominator'', ''exact->inexact'', ''expt'', ''floor'', ''gcd'', ''log'', ''max'', ''numerator'', ''quotient'', ''random'', ''remainder'', ''sqr'', and ''tan''.

''pi'', ''e''

Emacs Geiser does not show #i for inexact numbers:
'''
(sqrt 2)
1.4142135623730951
'''

DrRacket does:
'''
(sqrt 2)
#i1.4142135623730951
'''

However, Emacs with racket-mode REPL **does show #i** for inexact numbers.

==== 1.2 The Arithmetic of Strings ====
In the book: [[https://htdp.org/2020-8-1/Book/part_one.html#%28part._sec~3aarith-str%29|The Arithmetic of Strings]]

''1String'' such as ''"z"''. Three such ''1String''s may be used to for the name of a color: ''"red"'' ([[https://htdp.org/2020-8-1/Book/part_one.html#%28tech._1string%29|more about 1String]]). Simply put, they are strings of length 1.

In BSL, **only** ''string-append'' consume and produce strings. Other operations either consume or produce other types of data.

==== 1.3 Mixing It Up ====
In the book: [[https://htdp.org/2020-8-1/Book/part_one.html#%28part._sec~3aarith-mix%29|Mixing It Up]]

(substring "Lara Croft" 0 4)
"Lara"
(substring "Lara Croft" 5)
"Croft"

Wait!! It looks like ''substring'' **also** consumes and produces string (unless we get an error like index out of range, but erros can happen with ''string-append'' too.

==== 1.4 The Arithmetic of Images ====
In the book: [[https://htdp.org/2020-8-1/Book/part_one.html#%28part._sec~3aarith-images%29|The Arithmetic of Images]]

Anchor point.

==== 1.5 The Arithmetic of Booleans ====
In the book: [[https://htdp.org/2020-8-1/Book/part_one.html#%28part._sec~3aarith-bools%29|The Arithmetic of Booleans]]

'''
#true  #t  #false  #f
(and ...)
(or ...)
(not ...)
'''


==== 1.6 Mixing It Up with Booleans ====
In the book: [[https://htdp.org/2020-8-1/Book/part_one.html#%28part._sec~3aboolean-if%29|Mixing It Up with Booleans]]

==== 1.7 Predicates: Know Thy Data ====
In te book: [[https://htdp.org/2020-8-1/Book/part_one.html#%28part._sec~3apredicates%29|Predicates: Know Thy Data]]

BSL, also choose to use finite approximations to well-known constants, which leads to somewhat surprising results with the ''rational?'' predicate:

'''
(rational? pi)
;; → #t

(rational? e)
;; → #t
'''

BUT:

'''
(exact? pi)
;; → #f

(exact? e)
;; → #f

(inexact? pi)
;; → #t

(inexact? e)
;; → #t
'''


===== 2 Functions and Programs =====
In the book: [[https://htdp.org/2020-8-1/Book/part_one.html#%28part._ch~3afuncs-progs%29|Functions and Programs]]

==== 2.1 Functions ====
In the book: [[https://htdp.org/2020-8-1/Book/part_one.html#%28part._sec~3afuncs%29|Functions]]

Functions take input, //arguments// or //parameters//. A one-argument function is a //unary// function. There are also //binary //(two args), //ternary //(three args).

“The variables in a function header, that is, the variables that follow the function name, are placeholders for **unknown** pieces of data, the inputs of the function.”

Define a function, then **apply** the function.

==== 2.2 Computing ====
In the book: [[https://htdp.org/2020-8-1/Book/part_one.html#%28part._sec~3acomputing%29|Computing]]

==== 2.3 Composing Functions ====
In the book: [[https://htdp.org/2020-8-1/Book/part_one.html#%28part._sec~3acomposing%29|Composing Functions]]

“Typically, programs consist of a main definition and several other functions and turn the result of one function application into the input for another. In analogy to algebra, we call this way of defining functions //composition//, and we call these additional functions //auxiliary functions// or //helper functions//.”

'''
#lang htdp/bsl
(require 2htdp/batch-io)
(write-file 'stdout (letter ...))
'''


Define one function per task.


==== 2.4 Global Constants ====
In the book: [[https://htdp.org/2020-8-1/Book/part_one.html#%28part._sec~3aglobal%29|Global Constants]]

The name of a constant is a ''global variable'' while the definition is called a ''constant definition''. We tend to call the expression in a constant definition the ''right-hand side'' of the definition.

'''
; the current price of a movie ticket:
(define CURRENT-PRICE 5)
 
; useful to compute the area of a disk:
(define ALMOST-PI 3.14)
 
; a blank line:
(define NL "\n")
 
; an empty scene:
(define MT (empty-scene 100 100))

(define WIDTH 100)
(define HEIGHT 200)
 
(define MID-WIDTH (/ WIDTH 2))
(define MID-HEIGHT (/ HEIGHT 2))
'''


Computed constants.

For every constant mentioned in a problem statement, introduce one constant definition.

==== 2.5 Programs ====
In the book: [[https://htdp.org/2020-8-1/Book/part_one.html#%28part._sec~3aprogs%29|Programs]]

Batch vs interactive programs. Inputs are events. Event-driven programs. Event-handlers.

Big-bang 2htdp/univers, world programs.

===== 3 How to Design Programs =====
In the book: [[https://htdp.org/2020-8-1/Book/part_one.html#%28part._ch~3ahtdp%29|How to Design Programs]]

garage programming
programmign product

==== 3.1 Designing Functions ====
In the book: [[https://htdp.org/2020-8-1/Book/part_one.html#%28part._sec~3adesign-func%29|Designing Functions]]

information from the //domain//

information: facts about a problem domain

Process information and turn it into data for the program to work with. Once finished, data is turned into information again and displayed to the users somehow.

{{./domain-info-data.png?width=316}}

Given the central role of information and data, program design must start with the connection between them. Specifically, we, the programmers, must decide how to use our chosen programming language to represent the relevant pieces of information as data and how we should interpret data as information.

Data Definitions!

Lowest possible temperature -274ª C.


=== From Problem Analysis to Data Definitions ===

Identify the information that must be represented and how it is represented in the chosen programming language. Formulate data definitions and illustrate them with examples.

=== Signature, Purpose Statement, Header ===

State what kind of data the desired function consumes and produces. Formulate a concise answer to the question what the function computes. Define a stub that lives up to the signature.

=== Functional Examples ===

Work through examples that illustrate the function’s purpose.

=== Function Template ===

Translate the data definitions into an outline of the function.

=== Function Definition ===

Fill in the gaps in the function template. Exploit the purpose statement and the examples.

=== Testing ===

Articulate the examples as tests and ensure that the function passes all. Doing so discovers mistakes. Tests also supplement examples in that they help others read and understand the definition when the need arises—and it will arise for any serious program.

Purpose statement: “What does this function compute?”

Every reader of your program should understand what your functions compute without having to read the function itself.


==== 3.2 Finger Exercises: Functions ====
In the book: [[https://htdp.org/2020-8-1/Book/part_one.html#%28part._sec~3afinger-design%29|Finger Exercises: Functions]]

==== 3.3 Domain Knowledge ====
In the book: [[https://htdp.org/2020-8-1/Book/part_one.html#%28part._sec~3adomain%29|Domain Knowledge]]


==== 3.4 From Functions to Programs ====
In the book: [[https://htdp.org/2020-8-1/Book/part_one.html#%28part._sec~3adesign%29|From Functions to Programs]]

==== 3.5 On Testing ====
In the book: [[https://htdp.org/2020-8-1/Book/part_one.html#%28part._sec~3atesting%29|On Testing]]

==== 3.6 Designing World Programs ====
In the book: [[https://htdp.org/2020-8-1/Book/part_one.html#%28part._.D.K._sec~3adesign-world%29|Designing World Problems]]


==== 3.7 Virtual Pet Worlds ====
In the book: [[https://htdp.org/2020-8-1/Book/part_one.html#%28part._sec~3azoo1%29|Virtual Pet Worlds]]


===== 4 Intervals, Enumerations, and Itemizations =====
In the book: [[https://htdp.org/2020-8-1/Book/part_one.html#%28part._ch~3aintervals-enums%29|Intervals, Enumerations, and Itemizations]]

==== 4.1 Programming with Conditionals ====
In the book: [[https://htdp.org/2020-8-1/Book/part_one.html#%28part._sec~3acond%29|Programming with Conditionals]]

''cond'' expression, //cond clause// (cond lines, two expressions)

'''
(< 1 2 3) ; #t
(< 1 2 2) ; #f
(< 1 10 100) ; #t
(< 1 10 100 99) #f
'''

contrast with

'''
if (1 < 2 & 2 < 3) ...
'''

In ''cond'', the else clause is the **complement** of all the previous conditions.

{{./cond-else.png}}

Read: “if s is a value between 0 and 10. Easy, cool, elegant, short!

==== 4.2 Computing Conditionally ====
In the book: [[https://htdp.org/2020-8-1/Book/part_one.html#%28part._sec~3aworks%29|Computing Conditionally]]


==== 4.3 Enumerations ====
In the book: [[https://htdp.org/2020-8-1/Book/part_one.html#%28part._sec~3aenums%29|Enumerations]]

Enumeration: a data representation in which every possibility is listed.

=== Exercise 51 ===
[[https://htdp.org/2020-8-1/Book/part_one.html#%28counter._%28exercise._cond3%29%29|Exercise 51]]

samth@racket: “It doesn't matter what initial state you pick. The right choice has to do with something safe as the initial state.”

==== 4.4 Intervals ====

{{./htdp-intervals-open-closed.png}}

Left-open implies right-closed. Right-open implies left-closed!

“Intervals deserve special attention when you make up examples, that is, they deserve at least three kinds of examples: one from each end and another one from inside.”

**IMPORTANT**: For functional examples, however, it is imperative that you pick at least one example from each sub-class in the data definition. Also, if a sub-class is a finite range, be sure to pick examples from the boundaries of the range and from its interior.

==== 4.5 Itemizations ====
In the book: [[https://htdp.org/2020-8-1/Book/part_one.html#%28part._itemization._sec~3aitemization%29|Itemizations]].

**A Foo is one of**:
- 1String
- "left"
- ...

Enumeration: enumerate each possible item in the finite collection of data.
Intervals: as 

**INTERVALS**: An interval distinguishes different sub-classes of numbers, which, in principle, is an infinitely large class.

**ENUMERATIONS**: An enumeration spells out item for the useful elements of an existing class of data.

**ITEMIZTIONS**: Some data definitions need to include elements from both (intervals and enumerations). They use itemizations, which generalize intervals and enumerations. They allow the combination of any already-defined data classes with each other and with individual pieces of data.

{{./itemization-NorF.png}}

One ''cond'' per item.

The reference point of an image or shape.

==== 4.6 Designing with Itemizations ====

Instead of just writing down the expected result, we write down how to compute the expected result. This makes it easier later to formulate the function definition.

'''
(check-expect (add 1 1) 2)       ; NOPE...
(check-expect (add 1 1) (+ 1 1)) ; THIS IS MORE MEANINGFUL.
'''


'''
(check-expect (sales-tax 537) 0)
(check-expect (sales-tax 1000) (* 0.05 1000))
(check-expect (sales-tax 12017) (* 0.08 12017))
'''


Q: Think about why you may need more test cases than sub-classes in the data definition.

A: So I can assert the “edges” of the intervals, and other not-so-obvious cases that may need special care and attention, not just something “in the middle” of each sub-class.


==== 4.7 Finite State Worlds ====
In the book: [[https://htdp.org/2020-8-1/Book/part_one.html#%28part._sec~3aworlds-more%29|Finite State Worlds]]

State Transition Diagram: labels on arrows indicate why the state changed.

“In many situations, state transition diagrams have only a finite number of states and arrows. Computer scientists call such diagrams //finite state machines// (FSM), also known as //finite state automata// (FSA). Despite their simplicity, FSMs/FSAs play an important role in computer science.”

--------------------
We also keep in mind the lesson of exercise 61, namely, that it is best to define symbolic constants and formulate data definitions in terms of such constants. If the names are chosen properly, the data definition does not need an interpretation statement.

'''
(define RED 0)
(define GREEN 1)
(define YELLOW 2)

;;
; A TrafficLight is one of:
; • RED
; • GREEN
; • YELLOW
;
'''


'''
(define LOCKED "locked")
(define CLOSED "closed")
(define OPEN "open")

;;
; A DoorState is one of:
; • LOCKED
; • CLOSED
; • OPEN
;
'''



===== 5 Adding Structure =====

'''
(define p (make-posn -3 4))
(+ (posn-x p) (posn-y p);
'''


define-struct

constructor to create structure instance
one selector per field
structure predicate

In the book, MIDDLE is for vertical stuff, CENTER for horizontal.

In the MIDDLE of top/bottom vs in the CENTER of left/right.

{{./updater-functional-setter.png}}


===== 7 Summary =====

